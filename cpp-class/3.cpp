                                /******静态成员***********/
/*
可以定义类的静态成员，能够实现同类的多个对象之间的数据共享
1.静态数据成员在类里面申明，但同时需要在类外定义
2.静态数据成员可以用作默认实参，非静态数据类型不能
3.静态数据成员的作用域还是在类里面
4.同样的可以定义静态成员函数，里面不能调用*****非静态数据成员******（因为其没有this指针，其不能用const限定
5.静态数据成员的调用，cube：：count，静态成员函数即可以用类：：调用，也可以用对象调用
6.非静态成员函数可以调用静态成员函数
*/
                                /********友元和友元函数，友元类*************/
/*
1.关键字  friend
2.同样可以将一个类声明为另一个类的友元，其里面的函数都是另一个类的友元函数
3.友元的关系不能传递，继承
*/
                                /****************类的继承和派生***************/
/*
1.定义派生类  class 类名：派生类列表（访问标号和类名） {}；
2.继承方式，public，protected，和private，不写就默认private
3.派生类的成员的访问，派生类可以访问protected，派生类不能访问基类里的私有成员
4.派生类的友元只可以访问派生类自己的公有成员，私有成员和保护成员
5.public继承基类的公有成员和保护成员保留原来的访问属性，私有成员任为基类私有
private继承，基类的所有成员在派生类中为私有成员
protectd继承，基类的公有成员和保护成员在派生类中为保护成员，私有成员仍为基类私有
*/
                                    /*赋值兼容规则*/
/*
1.在任何需要基类对象的地方，都可以使用公有派生类的对象来代替
**派生类的对象可以赋值给基类的对象
**派生类的对象可以初始化基类的引用
**派生类对象的地址可以赋值给指向基类对象的指针
*/
                                /*派生类的构造函数和析构函数*/
/*
1.派生类不会继承构造函数和析构函数
*/
                                /*  多重继承    */
/*
1.一个类继承了多个基类
2.二义性问题：多个基类可能出现重名的问题，c.a：：fun（），调用c类中的a基类的fun函数，前面就是使用了成员名限定
*/
                            /*虚基类*/
/*
多重继承会造成二义性的问题，a派生出b1，b2；b1，b2分别派生出c1，c2；d继承了c1和c2，则在d类中，就含有两个a类
1.虚基类使得在继承间接公有成员时只保留一份成员
2.虚基类的声明：在派生类中进行声明
class 派生类名：virtual 访问标号 虚基类名，...{成员列表}
3.需要注意的是，为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中都声明为虚基类
*/
                            /*多态性*/
/*
1.多态和动态联编
2.重载多态：函数重载和运算符重载
3.强制多态，类型强制转换：表达式为1）static_cast<T>(E);2)T(E);3)(T)E
4.类型参数化多态：模板是实现类型参数化多态的工具，分为函数模板和类模板
5.包含多态：c++采用虚函数实现包含多态
************************静态联编和动态联编
静态联编：在编译的时候，就将函数的实现和函数的函数调用绑定在起来，
    c语言中所有的联编都是静态联编，c++中一般也是静态联编
动态联编：在程序运行时才进行函数调用和函数实现的绑定称为动态联编，指针和引用才能实现动态联编（前提），
动态联编的含义可以参照虚基类
                           ******虚函数*******
例如：cube1 c；cube *str=&c；加入基类和派生类中都有area函数，则一般来说，str-》area调用的是cube也就是基类的
函数，但如何使其调用的是派生类的函数呢？则可以把基类里的area函数声明为虚函数
声明为虚函数的方法：前面加virtual
1.作用就是实现多态性，实现一个接口，多种方式
2，只能在类体里使用
虚函数实现多态的条件
1.类之间的继承关系满足赋值兼容性规则
2.改写了同名的虚函数
3.根据赋值兼容规则使用指针或则引用，不能使用成员直接访问（是静态联编
*************虚析构函数，不能将构造函数申明为虚函数
如果用new建立一个派生类的对象，并且定义一个指向基类的指针指向这个派生类，当用delete撤销时，只会调用基类的
析构函数，并不能实现真正的空间释放，因为没有调用派生类里的析构函数
************纯虚函数
在许多情况下，不能在基类中为虚函数给出有意义的定义，可以将它申明为纯虚函数，将具体定义留给派生类去做
virtual 返回类型 函数名（形式参数表）=0；
意思是在基类中该函数没什么意义，但是派生类有意义
包含纯虚函数的类称为抽象类，抽象类不能用来定义对象，只能用来派生
*/
#include<iostream>
using namespace std;
class cube
{
    public:
            cube(int a=0,int b=0,int c=0,int d=0);
            cube(const cube& obj):color(obj.color),x(obj.x),y(obj.y),z(obj.z){}
            int size(int a,int b,int c);
            void output()const;//常成员函数
            ~cube()
            {
                cout<<"析构函数被调用"<<endl;
            }
            int color;
            static int count;
            friend int add(const cube& str);
            //静态成员,属于整个类，而不是属于任何一个对象，这里的count是为了计算cube类有多少个实例化的对象
            //友元函数，可以访问类中的私有数据，参数不能是类用户的调用形式
    private:
            int x,y;
    protected:
    int z;
};
//派生类并且声明基类cube为虚基类，就是在多重继承中，只保留一份副本
class cube1 :virtual public cube
{
    public:
    int i;
    cube1(int a):cube(),i(a)
    {
        cout<<"ok";
    }
    void output()
    {
        cout<<z;
    }
};

//静态对象不属于对象，属于类，每个类只有一个静态对象
//静态=0;数据成员需要类外定义并且初始化，类里面只是申明，其他数据成员不需要声明，因为其他数据会在对象的实例化过程中被定义
int cube::count=0;
//******************
int add(const cube &str)
{
    return str.x+str.y;
}
void cube::output()const
{
    cout<<color<<endl<<x<<endl<<endl<<y<<endl<<z;
}
int cube::size(int a,int b,int c)
{
    return a*b*c;
}
cube::cube(int a,int b,int c,int d):color(a),x(b),y(c),z(d)
{
    cout<<"ok"<<endl;
}
int main()
{
    cube1 a(1);
    cube b(1);
    cube1::count++;
    cout<<cube1::count;
    add(b);
    //赋值兼容规则
    cube1 c(2);
    cube d(1,1,1,1);
    cube& e=c;
    cout<<e.color;
    d=c;
    cout<<d.color;
    cube *str=&c;
    str->cube::color;//成员名限定
    cout<<str->color;
    return 0;
}